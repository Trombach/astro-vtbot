---
const TAG = 'vtbot-linter'; // see also start of script
---

<meta name={TAG} content="true" />

<script>
	import {
		TRANSITION_BEFORE_SWAP,
		type TransitionBeforeSwapEvent,
		isTransitionBeforeSwapEvent,
		supportsViewTransitions,
	} from 'astro:transitions/client';
	import { astroContextIds, deriveCSSSelector, elementsWithStyleProperty } from './css';

	const TAG = 'vtbot-linter';

	const enabled = () => !!document.querySelector(`meta[name="${TAG}"]`);
	const ERROR =
		'background-color: #880000; color: #ffffff; padding: 2px 4px; border-radius: 4px; font-weight: bold;';
	const WARNING =
		'background-color: #887700; color: #ffffff; padding: 2px 4px; border-radius: 4px;';
	const IMPORTANT = 'background-color:#eee; color: #333; font-weight: bold; padding: 2px 4px;';

	function flagNested(event: TransitionBeforeSwapEvent, property: string, origin?: 'old' | 'new') {
		const nameMap = new Map<string, Element>();

		const here = `in ${origin} DOM (${event[origin === 'old' ? 'from' : 'to'].pathname})`;

		if (!origin) {
			flagNested(event, property, 'old');
			flagNested(event, property, 'new');
			return;
		}
		const selector = `[${property}]`;
		const elements = (origin === 'old' ? document : event.newDocument).querySelectorAll(selector);

		elements.forEach((element) => {
			const name = element.getAttribute(property);
			if (!name) {
				console.groupCollapsed(`%c[vtbot-linter] no value given for ${selector} ${here}`, ERROR);
				console.log(`%o at %c${deriveCSSSelector(element)}`, element, IMPORTANT);
				console.groupEnd();
			} else {
				if (name.match(/astro-........-[0-9]+/)) {
					console.groupCollapsed(
						`%c[vtbot-linter] looks like an implicit name: ${property}=${name} ${here}`,
						WARNING
					);
					console.log(`%o at %c${deriveCSSSelector(element)}`, element, IMPORTANT);
					console.groupEnd();
				}
				const earlier = nameMap.get(name);
				if (earlier) {
					console.groupCollapsed(`%c[vtbot-linter] duplicate ${property}=${name} ${here}`, ERROR);
					console.log(
						`%o at %c${deriveCSSSelector(element)}%c and earlier %o at %c${deriveCSSSelector(
							earlier
						)}`,
						element,
						IMPORTANT,
						'',
						earlier,
						IMPORTANT
					);
					console.groupEnd();
				} else {
					nameMap.set(name, element);
				}
			}

			const violation = element.parentElement?.closest(selector);

			if (violation) {
				console.groupCollapsed(
					`%c[vtbot-linter] nested elements with ${selector} in ${origin} DOM (${
						event[origin === 'old' ? 'from' : 'to'].pathname
					})`,
					ERROR
				);
				console.log(
					`%o at %c${deriveCSSSelector(element)}%c is nested inside %o at %c${deriveCSSSelector(
						violation
					)}`,
					element,
					IMPORTANT,
					'',
					violation,
					IMPORTANT
				);
				console.groupEnd();
			}
		});
	}

	function flagNonUniqueOrMissingTransitionNames(
		event: TransitionBeforeSwapEvent,
		origin: 'old' | 'new'
	) {
		const here = `in ${origin} DOM (${event[origin === 'old' ? 'from' : 'to'].pathname})`;

		const namedElements = elementsWithStyleProperty('view-transition-name');
		[...namedElements.keys()].forEach((name) => {
			const elements = namedElements.get(name)!;
			if (elements.size === 0) {
				console.log(
					`%c[vtbot-linter] no HTMLElement with view transition name "${name}" exists ${here}. Does it got overridden by transition:persist or data-vtbot-replace?`,
					WARNING
				);
			}
			if (elements!.size > 1) {
				console.groupCollapsed(
					`%c[vtbot-linter] view transition name "${name}" is not unique ${here}`,
					ERROR
				);
				[...elements!.values()]?.forEach((element, idx) => {
					const newName = `${name}${idx}`;
					console.log(`%o at %c${deriveCSSSelector(element)}`, element, IMPORTANT);
				});
				console.groupEnd();
			}
		});
	}

	function flagMissingScopedStyles(event: TransitionBeforeSwapEvent, origin: 'old' | 'new') {
		const here = `in ${origin} DOM (${event[origin === 'old' ? 'from' : 'to'].pathname})`;
		const { inStyleSheets, inElements } = astroContextIds();
		//[...inElements].forEach((id) => console.log('eid :>> ', id));
		//[...inStyleSheets].forEach((id) => console.log('sid :>> ', id));
		const notDefined = new Set([...inElements].filter((id) => !inStyleSheets.has(id)));
		const notUsed = new Set([...inStyleSheets].filter((id) => !inElements.has(id)));
		notDefined.forEach((id) => {
			console.groupCollapsed(
				`%c[vtbot-linter] scoped style id "${id}" is not defined ${here}. `,
				WARNING
			);
			[...document.querySelectorAll(`[data-astro-cid-${id}], [class*="astro-${id}"]`)]
				.filter((e, _, arr) => !arr.includes(e.parentElement!))
				.forEach((e) => console.log(e));
				console.log("%c[vtbot-linter] The stylesheet might got optimized away or the element might have lost its styling when being copied by transition:persist or data-vtbot-replace.",IMPORTANT);
			console.groupEnd();
		});
		notUsed.forEach((id) => {
			console.log(
				`%c[vtbot-linter] scoped style id "${id}" is defined ${here} but not used. `,
				WARNING
			);
		});
	}

	const beforeSwap = (event: Event) => {
		if (enabled() && isTransitionBeforeSwapEvent(event)) {
			flagNested(event, 'data-astro-transition-persist');
			flagNested(event, 'data-vtbot-replace');
			if (supportsViewTransitions) {
				flagNonUniqueOrMissingTransitionNames(event, 'old');
				flagMissingScopedStyles(event, 'old');
				const originalSwap = event.swap;
				event.swap = () => {
					originalSwap();
					flagNonUniqueOrMissingTransitionNames(event, 'new');
					flagMissingScopedStyles(event, 'new');
				};
			} else {
				console.log(
					'%c[vtbot-linter] check for unique view transition names not supported in this browser',
					ERROR
				);
			}
		}
	};

	document.addEventListener(TRANSITION_BEFORE_SWAP, beforeSwap);
</script>

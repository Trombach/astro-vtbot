---
export interface Props {
	production?: boolean;
}
const TAG = 'vtbot-debug';
const { production = false } = Astro.props;
const active = import.meta.env.DEV || production;
---

{active && <meta name={TAG} content='true'/>}

{active &&<script is:inline>
	// start of "early" part
	/*
	 * Register as early as possible (=inline script early in head)
	 * to capture the original data of the events.
	 */
	(function iife() {
		const PREFIX = '[vtbot-debug]';
		const enabled = () => document.querySelector('meta[name="vtbot-debug"]');

		/*
		 * capture the original data of the events
		 */
		const doCapture = (e) => {
			window._vtbot_debug.capture = {
				...e,
				type: e.type,
				cancelable: e.cancelable,
				defaultPrevented: e.defaultPrevented,
				event: e,
			};
		};

		/*
		 * capture the event properties at beginning of the processing phase
		 */
		const startProcessing = (e) => {
			doCapture(e);
			if (enabled()) {
				console.log(`${PREFIX} Event handler for ${e.type}`);
			}
		};

		/*
		 * Register the two "early" handlers
		 */
		if (window._vtbot_debug === undefined) {
			window._vtbot_debug = {};
			document.addEventListener('astro:before-preparation', startProcessing);
			document.addEventListener('astro:before-swap', startProcessing);
		}
		// end of "early" part
	})();
</script>}

<script>
	// start of "late" part in (defered loaded) module script
	import {
		isTransitionBeforePreparationEvent,
		isTransitionBeforeSwapEvent,
		type TransitionBeforePreparationEvent,
		type TransitionBeforeSwapEvent,
		TRANSITION_BEFORE_PREPARATION,
		TRANSITION_AFTER_PREPARATION,
		TRANSITION_BEFORE_SWAP,
		TRANSITION_AFTER_SWAP,
		TRANSITION_PAGE_LOAD,
		supportsViewTransitions,
	} from 'astro:transitions/client';
	import { deriveCSSSelector, elementsWithStyleProperty } from './css';

	const enabled = () => !!document.querySelector('meta[name="vtbot-debug"]');
	const PREFIX = '[vtbot-debug]';


	/*
	 * address/content surrogate
	 */
	let addressCounter = 0;
	const mem = new WeakMap();
	const doc = (obj: Document) => {
		const units = ['B', 'kB', 'MB'];
		const humanReadable = (n: number) => {
			let i = 0;
			while ((n /= 1024) > 1 && i++ < units.length);
			return `${(n * 1024).toFixed(1)} ${units[i]}`;
		};
		const a = mem.get(obj) ?? `${++addressCounter}`;
		const html = obj.documentElement.outerHTML;
		mem.set(obj, a);
		return `@${a} (${humanReadable(html.length)})`;
	};

	const logWithStyle = (s: string) => {
		// @ts-ignore
		const _vtbot_debug = window._vtbot_debug;
			const css: string[] = [];
			s = s.replaceAll('**', '%c');
			const count = (s.match(/%c/g) || []).length / 2;
			for (let i = 0; i < count; i++) {
				css.push('display: inline-block; border: dotted 1pt gray; padding: 0 4pt;font-weight: 800');
				css.push('font-weight: normal');
			}
			console.log(s, ...css);
	};

	/*
	 * log a property of the event
	 */
	async function delta(e: Record<string, any>, prop: string, deltaOnly = false) {
		// @ts-ignore
		const _vtbot_debug = window._vtbot_debug;
		const bold = (s: string) => `**${s}**`;
		let deref = (x: any) => x;
		let print = (x: any) => x;
		let value = (x: any) => x;

		if (prop === 'to' || prop === 'from') {
			deref = (x) => x?.href;
			print = deref;
		} else if (prop === 'newDocument') {
			print = doc;
			value = doc;
		} else if (prop === 'swap' || prop === 'loader') {
			print = (x) => {
				const s = x ? x.toString() : '(null)';
				const max = 60;
				return s.length < max ? s : s.substring(0, max - 4) + ' ...';
			};
		}

		let different = () => value(deref(_vtbot_debug.capture[prop])) !== value(deref(e[prop]));

		if (different()) {
			logWithStyle(
				`${PREFIX} ${prop} changed from ${bold(print(_vtbot_debug.capture[prop]))} to ${bold(
					print(e[prop])
				)}`
			);
		} else if (!deltaOnly) {
			logWithStyle(`${PREFIX} ${prop}: ${bold(print(e[prop]))}`);
		}
	}

	/*
	 * Capture the event properties
	 */
	const doCapture = (e: Event) => {
		// @ts-ignore
		window._vtbot_debug.capture = {
			...e,
			type: e.type,
			cancelable: e.cancelable,
			defaultPrevented: e.defaultPrevented,
			event: e,
		};
	};

	/*
	 * log the properties of the event
	 */
	function logProperties(
		e: TransitionBeforePreparationEvent | TransitionBeforeSwapEvent,
		deltaOnly = false
	) {
		delta(e, 'type', deltaOnly);
		delta(e, 'cancelable', deltaOnly);
		delta(e, 'defaultPrevented', deltaOnly);
		delta(e, 'from', deltaOnly);
		delta(e, 'to', deltaOnly);
		delta(e, 'direction', deltaOnly);
		delta(e, 'navigationType', deltaOnly);
		delta(e, 'info', deltaOnly);
		delta(e, 'newDocument', deltaOnly);
		if (isTransitionBeforePreparationEvent(e)) {
			delta(e, 'formData', deltaOnly);
			delta(e, 'loader', deltaOnly);
		}
		if (isTransitionBeforeSwapEvent(e)) {
			delta(e, 'swap', deltaOnly);
		}
		doCapture(e);
	}


	/*
	 * Log beforePreparation
	 */
	function beforePreparation(preparationEvent: Event) {
		if (enabled()) {
			if (isTransitionBeforePreparationEvent(preparationEvent)) {
					console.groupCollapsed(`${PREFIX} Properties of the ${preparationEvent.type} event`);
					logProperties(preparationEvent);
					console.groupEnd();
				const originalLoader = preparationEvent.loader;
				preparationEvent.loader = async () => {
					console.log(`${PREFIX} before execution of loader()`);
					await originalLoader();
					logProperties(preparationEvent, true);
					console.log(`${PREFIX} after execution of loader()`);
				};
				doCapture(preparationEvent);
			} else {
				console.log('not a TransitionBeforePreparationEvent');
			}
		}
	}

	const logTransitions = (
		originalMap: Map<string, Set<Element>> | undefined,
		swapEvent: TransitionBeforeSwapEvent
	) => {
		if (originalMap === undefined) return;

		const errors: string[] = [];
		const transitions: string[] = [];

		// @ts-ignore
		const overlay = _vtbot_debug?.savedFunctions?.log;
		const bold = (s: string) => `**${s}**`;
		const newMap = elementsWithStyleProperty('view-transition-name');
		newMap.set('root', (newMap.get('root') ?? new Set()).add(document.documentElement));
		let i = 0;

		new Set([...originalMap.keys(), ...newMap.keys()]).forEach((name) => {
			if (name) {
				const oldSet = originalMap.get(name);
				if (supportsViewTransitions && (oldSet?.size ?? 0) > 1) {
					errors.push(
						`${bold('ERROR')} view-transition-name ${bold(name)} is not unique in old document\n`
					);
				}
				const newSet = newMap.get(name);
				if (supportsViewTransitions && (newSet?.size ?? 0) > 1) {
					errors.push(
						`${bold('ERROR')} view-transition-name ${bold(name)} is not unique in new document\n`
					);
				}
				const oldElement = oldSet ? [...oldSet][0] : undefined;
				const newElement = newSet ? [...newSet][0] : undefined;
				
					transitions.push(
						`[ transition] ${++i} "${bold(name)}" from ${bold(
							oldElement ? deriveCSSSelector(oldElement) : '(nowhere)'
						)} --to-> ${bold(newElement ? deriveCSSSelector(newElement) : '(nowhere)')}`
					);
			}
		});
		errors.forEach((s) => logWithStyle(s));
			console.groupCollapsed(
				`${PREFIX} Transitions from ${swapEvent.from.pathname} to ${swapEvent.to.pathname}`
			);
			transitions.forEach((s) => logWithStyle(s));
			console.groupEnd();
		
	};

	const moduleScripts = new Set();
	const recordScripts = () =>
		[...document.scripts].forEach(
			(script) => script.type === 'module' && script.src && moduleScripts.add(script.src)
		);

	function logScripts() {
		let modules = '';
		const toExecute = [...document.scripts].filter(
			(s) =>
				s.dataset.astroExec !== "" &&
				(!s.type || s.type === 'module' || s.type === 'text/javascript') &&
				(s.type !== 'module' ||
					!s.src ||
					!moduleScripts.has(s.src) ||
					((modules += s.src + ' '), false))
		);
		if (toExecute.length > 0) {
			let i = 0;
			logWithStyle(
				`${PREFIX} **Scripts** that execute between astro:after-swap and astro:page-load: (${toExecute.length})`
			);
			toExecute.forEach((script) => {
				script.type === 'module' && script.src && moduleScripts.add(script.src);
				let s = `${PREFIX} ${++i}. `;
				for (const attribute of script.attributes) {
					s += `${attribute.name}="${attribute.value}" `;
				}
				logWithStyle(
					s + (script.textContent ?? '').replace(/\n|\s+/g, ' ').substring(0, 60) + '...'
				);
			});
			if (modules) {
				logWithStyle(
					`${PREFIX} **Modules scripts** can't be re-executed until next full page reload: ` +
						modules
				);
			}
		}
	}

	/*
	 * Log swap
	 */
	function beforeSwap(swapEvent: Event) {
		if (enabled()) {
			recordScripts();
			if (isTransitionBeforeSwapEvent(swapEvent)) {
					console.groupCollapsed(`${PREFIX} Properties of the ${swapEvent.type} event`);
					logProperties(swapEvent);
					console.groupEnd();
				
				// @ts-ignore
				const _vtbot_debug = window._vtbot_debug;
				_vtbot_debug.originalMap = elementsWithStyleProperty('view-transition-name');
				_vtbot_debug.originalMap.set(
					'root',
					(_vtbot_debug.originalMap.get('root') ?? new Set()).add(document.documentElement)
				);
				const originalSwap = swapEvent.swap;
				swapEvent.swap = async () => {
					console.log(`${PREFIX} before execution of swap()`);
					originalSwap();
					// @ts-ignore
					logProperties(window._vtbot_debug.capture.event, true);
					console.log(`${PREFIX} after execution of swap()`);
					console.log(`${PREFIX} %o`, document.documentElement);
					// @ts-ignore
					window._vtbot_debug.savedSwapEvent = swapEvent;
				};
				doCapture(swapEvent);
				swapEvent.viewTransition.updateCallbackDone.then(
					() => console.log(`${PREFIX} resolve viewTransition.updateCallbackDone`),
					(error: any) =>
						console.log(`${PREFIX} reject viewTransition.updateCallbackDone with`, error)
				);
				swapEvent.viewTransition.ready.then(
					() => console.log(`${PREFIX} resolve viewTransition.ready`),
					(error: any) => console.log(`${PREFIX} reject viewTransition.ready with`, error)
				);
				swapEvent.viewTransition.finished.then(
					() => {
						console.log(`${PREFIX} resolve viewTransition.finished`);
					},
					(error: any) => {
						console.log(`${PREFIX} reject viewTransition.finished with`, error);
					}
				);
			} else {
				console.log('not a TransitionBeforeSwapEvent');
			}
		}
	}

	const afterSwap = (e) => {
		if (enabled()) {
			// @ts-ignore
			const event = window._vtbot_debug.capture.event;
			logProperties(event, true);
			console.log(`${PREFIX} Event handler for ${e.type}`);
			// @ts-ignore
			const _vtbot_debug = window._vtbot_debug;
			logTransitions(_vtbot_debug.originalMap, _vtbot_debug.savedSwapEvent);
			logScripts();
		}
	}

	/*
	 * Register the "late" handlers
	 */
		// register as late as possible (= in pageshow event) to be the last handler in the chain
		window.addEventListener('pageshow', () => {
			console.log(
				`${PREFIX} Registering event listeners for '${TRANSITION_BEFORE_PREPARATION}', '${TRANSITION_AFTER_PREPARATION}', '${TRANSITION_BEFORE_SWAP}', '${TRANSITION_AFTER_SWAP}' and '${TRANSITION_PAGE_LOAD}'`
			);
			document.addEventListener(TRANSITION_BEFORE_PREPARATION, beforePreparation);
			document.addEventListener(TRANSITION_AFTER_PREPARATION, (e) => {
				if (enabled()) {
					// @ts-ignore
					logProperties(window._vtbot_debug.capture.event, true);
					console.log(`${PREFIX} Event handler for ${e.type}`);
				}
			});
			document.addEventListener(TRANSITION_BEFORE_SWAP, beforeSwap);
			document.addEventListener(TRANSITION_AFTER_SWAP, afterSwap);
			document.addEventListener(TRANSITION_PAGE_LOAD, (e) => {
				if (enabled()) {
					// @ts-ignore
					logProperties(window._vtbot_debug.capture.event, true);
					console.log(`${PREFIX} Event handler for ${e.type}`);
				}
			});
			/*
			document.addEventListener('animationstart', (e) => {
				if (enabled() && e instanceof AnimationEvent) {
					console.log(`${PREFIX} ${e.animationName} started on ${e.target}`);
				}
			});
			document.addEventListener('animationend', (e) => {
				if (enabled()) {
					console.log(`${PREFIX} %o`, e);
				}
			});
			*/
		});
	
</script>
